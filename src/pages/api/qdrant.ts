import { NextApiRequest, NextApiResponse } from 'next';import { QdrantClient } from '@qdrant/js-client-rest';import dotenv from 'dotenv';// Load environment variablesdotenv.config();// Define the Qdrant client configurationconst QDRANT_URL = 'https://1ab8e412-8310-4e7d-ad9f-e285b0f92609.us-east-1-0.aws.cloud.qdrant.io:6333';const QDRANT_API_KEY = process.env.QDRANT_API_KEY || '';// Initialize the Qdrant client (server-side only)const qdrantClient = new QdrantClient({  url: QDRANT_URL,  apiKey: QDRANT_API_KEY,});// Simple rate limiting implementationinterface RateLimitEntry {  count: number;  resetTime: number;}const RATE_LIMIT_WINDOW = 60 * 1000; // 1 minuteconst RATE_LIMIT_MAX_REQUESTS = 30; // 30 requests per minuteconst rateLimitMap = new Map<string, RateLimitEntry>();// Helper function to get client IPconst getClientIp = (req: NextApiRequest): string => {  const forwarded = req.headers['x-forwarded-for'];  const ip = typeof forwarded === 'string'     ? forwarded.split(/, /)[0]     : req.socket.remoteAddress || 'unknown';  return ip || 'unknown';};// Check rate limit for a clientconst checkRateLimit = (clientIp: string): { allowed: boolean; resetTime?: number } => {  const now = Date.now();  const entry = rateLimitMap.get(clientIp);    if (!entry) {    // First request from this client    rateLimitMap.set(clientIp, {      count: 1,      resetTime: now + RATE_LIMIT_WINDOW    });    return { allowed: true };  }    if (now > entry.resetTime) {    // Rate limit window has passed, reset counter    rateLimitMap.set(clientIp, {      count: 1,      resetTime: now + RATE_LIMIT_WINDOW    });    return { allowed: true };  }    if (entry.count < RATE_LIMIT_MAX_REQUESTS) {    // Increment counter    entry.count += 1;    rateLimitMap.set(clientIp, entry);    return { allowed: true };  }    // Rate limit exceeded  return {     allowed: false,    resetTime: entry.resetTime  };};export default async function handler(  req: NextApiRequest,  res: NextApiResponse) {  if (req.method !== 'POST') {    return res.status(405).json({ error: 'Method not allowed' });  }  // Check rate limit  const clientIp = getClientIp(req);  const rateLimitCheck = checkRateLimit(clientIp);    if (!rateLimitCheck.allowed) {    const resetInSeconds = Math.ceil((rateLimitCheck.resetTime! - Date.now()) / 1000);    res.setHeader('X-RateLimit-Limit', RATE_LIMIT_MAX_REQUESTS.toString());    res.setHeader('X-RateLimit-Remaining', '0');    res.setHeader('X-RateLimit-Reset', Math.ceil(rateLimitCheck.resetTime! / 1000).toString());    return res.status(429).json({       error: 'Rate limit exceeded',      message: `Too many requests, please try again in ${resetInSeconds} seconds`    });  }  try {    const { operation, collectionName, point, points, vectorSize, vector, filter, limit = 10 } = req.body;    switch (operation) {      case 'getCollections':        const collections = await qdrantClient.getCollections();        return res.status(200).json({ collections: collections.collections });      case 'getCollectionInfo':        if (!collectionName) {          return res.status(400).json({ error: 'Missing collectionName' });        }        try {          const collectionInfo = await qdrantClient.getCollection(collectionName);          return res.status(200).json({ collectionInfo });        } catch (error) {          console.error('Error getting collection info:', error);          return res.status(404).json({ error: `Collection ${collectionName} not found` });        }      case 'createCollection':        if (!collectionName || !vectorSize) {          return res.status(400).json({ error: 'Missing collectionName or vectorSize' });        }        await qdrantClient.createCollection(collectionName, {          vectors: {            size: vectorSize,            distance: 'Cosine',          },        });        return res.status(200).json({ success: true });      case 'uploadPoint':        if (!collectionName || !point) {          return res.status(400).json({ error: 'Missing collectionName or point' });        }        await qdrantClient.upsert(collectionName, {          points: [            {              id: point.id,              vector: point.vector,              payload: point.payload || {},            },          ],        });        return res.status(200).json({ success: true });      case 'uploadPoints':        if (!collectionName || !points || !Array.isArray(points)) {          return res.status(400).json({ error: 'Missing collectionName or points' });        }        await qdrantClient.upsert(collectionName, {          points: points.map((point) => ({            id: point.id,            vector: point.vector,            payload: point.payload || {},          })),        });        return res.status(200).json({ success: true });      case 'search':        if (!collectionName || !vector) {          return res.status(400).json({ error: 'Missing collectionName or vector' });        }        const searchResults = await qdrantClient.search(collectionName, {          vector,          filter,          limit,        });        return res.status(200).json({ results: searchResults });      default:        return res.status(400).json({ error: 'Invalid operation' });    }  } catch (error: any) {    console.error('Error in Qdrant operation:', error);        // Special handling for collection already exists error    if (error.status === 409 && error.data?.status?.error?.includes('already exists')) {      return res.status(200).json({         success: true,         message: 'Collection already exists'       });    }        // Handle Qdrant API errors more gracefully    if (error.response) {      const status = error.response.status || 500;      const message = error.response.data?.message || 'Unknown Qdrant API error';      return res.status(status).json({ error: message });    }        return res.status(500).json({       error: 'Failed to perform Qdrant operation',      message: error.message || 'Unknown error'    });  }} 